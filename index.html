<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battery Blaster - Energy Transition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #gameWrapper {
            display: flex;
            gap: 0;
        }
        #gameContainer {
            position: relative;
            border: 4px solid #00ff88;
            border-right: 2px solid #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5), inset 0 0 30px rgba(0, 255, 136, 0.1);
        }
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }
        #sidePanel {
            width: 200px;
            background: #0d0d1a;
            border: 4px solid #00ff88;
            border-left: 2px solid #00ff88;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }
        .panel-section {
            margin-bottom: 20px;
        }
        .panel-title {
            color: #00ff88;
            font-size: 11px;
            letter-spacing: 2px;
            border-bottom: 1px solid #00ff8844;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 11px;
        }
        .stat-label {
            color: #88ffcc;
        }
        .stat-value {
            color: #ffffff;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff88;
        }
        .charge-bar-container {
            width: 100%;
            height: 20px;
            background: #1a1a2e;
            border: 2px solid #00ff8844;
            margin-top: 5px;
        }
        .charge-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #88ffcc);
            transition: width 0.1s;
            box-shadow: 0 0 10px #00ff88;
        }
        .energy-stat {
            background: #0a0a12;
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #00ff88;
        }
        .energy-stat .stat-value {
            font-size: 16px;
            display: block;
            margin-top: 2px;
        }
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff88;
            text-align: center;
            z-index: 10;
        }
        #startScreen h1, #gameOverScreen h1 {
            font-size: 32px;
            margin-bottom: 5px;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            animation: pulse 1.5s ease-in-out infinite;
        }
        #startScreen h2 {
            font-size: 12px;
            color: #88ffcc;
            letter-spacing: 4px;
            margin-bottom: 30px;
        }
        .subtitle {
            font-size: 14px;
            color: #ffaa00;
            margin-bottom: 25px;
        }
        .controls {
            font-size: 11px;
            color: #aaaaaa;
            margin: 15px 0;
            line-height: 2;
            background: #0a0a1266;
            padding: 15px 25px;
            border: 1px solid #00ff8833;
        }
        .controls strong {
            color: #00ff88;
            display: block;
            margin-bottom: 5px;
        }
        .start-btn {
            margin-top: 25px;
            padding: 15px 50px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: transparent;
            border: 3px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .start-btn:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 30px #00ff88;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }
        .final-stats {
            margin: 20px 0;
            font-size: 13px;
            line-height: 2.2;
            text-align: left;
            background: #0a0a1266;
            padding: 15px 25px;
            border: 1px solid #00ff8833;
        }
        .final-stats div {
            display: flex;
            justify-content: space-between;
            gap: 30px;
        }
        .final-stats span {
            color: #ffaa00;
            font-weight: bold;
        }
        #gameOverScreen {
            display: none;
        }
        .aim-indicator {
            color: #666;
            font-size: 10px;
            margin-top: 10px;
        }
        .wave-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }
        /* Mobile styles */
        @media (max-width: 768px), (pointer: coarse) {
            body {
                padding: 0;
                overflow: hidden;
            }
            #gameWrapper {
                flex-direction: column;
                width: 100vw;
                height: 100vh;
                height: 100dvh;
            }
            #gameContainer {
                border: none;
                border-bottom: 2px solid #00ff88;
                width: 100%;
                height: 65vh;
                height: 65dvh;
                position: relative;
                box-shadow: none;
            }
            #gameCanvas {
                width: 100%;
                height: 100%;
                object-fit: contain;
            }
            #sidePanel {
                display: none;
            }
            #startScreen, #gameOverScreen {
                border-radius: 0;
            }
            #startScreen h1 {
                font-size: 22px;
                margin-bottom: 2px;
            }
            #startScreen h2 {
                font-size: 9px;
                margin-bottom: 10px;
            }
            .subtitle {
                font-size: 12px;
                margin-bottom: 15px;
            }
            .controls {
                font-size: 9px;
                padding: 8px 12px;
                margin: 10px 0;
            }
            .start-btn {
                padding: 10px 30px;
                font-size: 13px;
                margin-top: 15px;
            }
            #startScreen > p[style] {
                display: none;
            }
            .final-stats {
                font-size: 11px;
                padding: 10px 15px;
                margin: 10px 0;
            }
            #gameOverScreen h1 {
                font-size: 22px;
            }
            #gameOverScreen .subtitle {
                font-size: 11px;
            }
            #gameOverScreen > p[style] {
                display: none;
            }
        }
        /* Mobile Controls Area */
        #mobileControls-area {
            display: none;
        }
        @media (max-width: 768px), (pointer: coarse) {
            #mobileControls-area {
                display: flex;
                width: 100%;
                height: 35vh;
                height: 35dvh;
                background: linear-gradient(180deg, #0d0d1a 0%, #0a0a12 100%);
                border-top: 2px solid #00ff8844;
                position: relative;
                align-items: center;
                justify-content: center;
                touch-action: none;
            }
            .touch-zone-hint {
                color: #00ff8844;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                text-align: center;
                pointer-events: none;
                user-select: none;
            }
            .touch-zone-hint span {
                display: block;
                margin-top: 5px;
                font-size: 9px;
                color: #00ff8866;
            }
            #mobileFactContainer {
                position: absolute;
                bottom: 10px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid #00ff8833;
                padding: 8px 12px;
                pointer-events: none;
            }
            .mobile-fact-label {
                color: #00ff8866;
                font-size: 8px;
                letter-spacing: 1px;
                margin-bottom: 3px;
                font-family: 'Courier New', monospace;
            }
            #mobileFactDisplay {
                color: #88ffcc;
                font-size: 10px;
                line-height: 1.4;
                font-family: 'Courier New', monospace;
            }
            #mobileHUD {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                display: flex;
                justify-content: space-around;
                padding: 8px 5px;
                background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
                z-index: 100;
                pointer-events: none;
            }
            .mobile-stat {
                background: transparent;
                padding: 3px 8px;
                border: none;
                color: #00ff88;
                font-size: 10px;
                font-family: 'Courier New', monospace;
                text-shadow: 0 0 5px #00ff88;
            }
            .mobile-charge-bar {
                width: 50px;
                height: 6px;
                background: #1a1a2e;
                border: 1px solid #00ff8844;
                display: inline-block;
                vertical-align: middle;
                margin-left: 3px;
            }
            .mobile-charge-fill {
                height: 100%;
                background: #00ff88;
                transition: width 0.1s;
            }
            #mobilePauseBtn {
                pointer-events: auto;
                padding: 3px 10px;
                border: 1px solid #00ff8866 !important;
                background: rgba(0,0,0,0.5) !important;
            }
        }
        .touch-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid rgba(0, 255, 136, 0.5);
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }
        .touch-indicator-inner {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        /* Name prompt modal */
        #namePrompt {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }
        #namePrompt h2 {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ff88;
        }
        #namePrompt p {
            font-size: 12px;
            color: #88ffcc;
            margin-bottom: 20px;
        }
        #namePrompt input {
            padding: 12px 20px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: #0a0a12;
            border: 2px solid #00ff88;
            color: #00ff88;
            text-align: center;
            width: 250px;
            margin-bottom: 15px;
        }
        #namePrompt input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        #namePrompt input::placeholder {
            color: #00ff8866;
        }
        #namePrompt .prompt-buttons {
            display: flex;
            gap: 15px;
        }
        #namePrompt button {
            padding: 10px 25px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s;
        }
        #namePrompt button:hover {
            background: #00ff88;
            color: #000;
        }
        #namePrompt .skip-btn {
            border-color: #666;
            color: #666;
        }
        #namePrompt .skip-btn:hover {
            background: #666;
            color: #000;
        }
        /* Scoreboard styles */
        .scoreboard {
            margin: 15px 0;
            background: #0a0a1266;
            border: 1px solid #00ff8833;
            padding: 10px 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        .scoreboard-title {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 2px;
            margin-bottom: 10px;
            border-bottom: 1px solid #00ff8844;
            padding-bottom: 5px;
        }
        .scoreboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 11px;
            border-bottom: 1px solid #00ff8822;
        }
        .scoreboard-entry:last-child {
            border-bottom: none;
        }
        .scoreboard-entry.current-player {
            color: #ffaa00;
            font-weight: bold;
        }
        .scoreboard-rank {
            color: #00ff88;
            width: 25px;
        }
        .scoreboard-name {
            flex: 1;
            color: #88ffcc;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            margin: 0 10px;
        }
        .scoreboard-score {
            color: #ffffff;
            text-shadow: 0 0 5px #00ff88;
        }
        .scoreboard-loading {
            color: #666;
            font-size: 11px;
            text-align: center;
            padding: 10px;
        }
        @media (max-width: 768px), (pointer: coarse) {
            #namePrompt h2 {
                font-size: 18px;
            }
            #namePrompt input {
                width: 200px;
                font-size: 14px;
            }
            .scoreboard {
                max-height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Name Prompt Modal -->
    <div id="namePrompt">
        <h2>ENTER YOUR CALLSIGN</h2>
        <p>Join the leaderboard and track your high scores</p>
        <input type="text" id="playerNameInput" placeholder="Your name..." maxlength="20" autocomplete="off">
        <div class="prompt-buttons">
            <button onclick="submitPlayerName()">CONFIRM</button>
            <button class="skip-btn" onclick="skipNameEntry()">SKIP</button>
        </div>
    </div>

    <div id="gameWrapper">
        <div id="gameContainer">
            <canvas id="gameCanvas" width="700" height="600"></canvas>

            <div id="startScreen">
                <h1>BATTERY BLASTER</h1>
                <h2>THE ENERGY TRANSITION</h2>
                <p class="subtitle">Defend the grid with clean energy!</p>
                <div class="controls" id="desktopControls">
                    <strong>CONTROLS</strong>
                    WASD / ARROWS - Move Battery<br>
                    AIM WITH MOUSE - Point to target<br>
                    CLICK / SPACE - Fire Electric Charge<br>
                    P - Pause Game
                </div>
                <div class="controls" id="mobileControls" style="display: none;">
                    <strong>TOUCH CONTROLS</strong>
                    TAP - Fire in current direction<br>
                    HOLD - Auto-fire continuously<br>
                    DRAG - Move battery
                </div>
                <p style="font-size: 10px; color: #666; max-width: 350px; margin-top: 15px; line-height: 1.6;">
                    Battery energy storage is revolutionizing the grid by replacing<br>
                    polluting gas peaker plants with clean, instant power.
                </p>
                <button class="start-btn" onclick="startGame()">START MISSION</button>
            </div>

            <div id="gameOverScreen">
                <h1>GRID OVERLOADED</h1>
                <p class="subtitle">The turbines overwhelmed the battery!</p>
                <div class="final-stats">
                    <div><span class="stat-label">Final Score</span><span id="finalScore">0</span></div>
                    <div><span class="stat-label">Waves Completed</span><span id="finalWaves">0</span></div>
                    <div><span class="stat-label">MW Dispatched</span><span id="finalMW">0</span></div>
                    <div><span class="stat-label">CO2 Avoided</span><span id="finalCO2">0</span> kg</div>
                    <div><span class="stat-label">Turbines Retired</span><span id="finalTurbines">0</span></div>
                </div>
                <div id="scoreboardContainer" class="scoreboard" style="display: none;">
                    <div class="scoreboard-title">TOP OPERATORS</div>
                    <div id="scoreboardList">
                        <div class="scoreboard-loading">Loading rankings...</div>
                    </div>
                </div>
                <p style="font-size: 11px; color: #88ffcc; max-width: 300px;">
                    Every battery deployed helps accelerate<br>the transition to clean energy.
                </p>
                <button class="start-btn" onclick="startGame()">TRY AGAIN</button>
            </div>

            <div class="touch-indicator" id="touchIndicator">
                <div class="touch-indicator-inner"></div>
            </div>

            <div id="mobileHUD" style="display: none;">
                <div class="mobile-stat">
                    SCORE: <span id="mobileScore">0</span>
                </div>
                <div class="mobile-stat">
                    WAVE: <span id="mobileWave">1</span>
                </div>
                <div class="mobile-stat">
                    <span id="mobileChargeLabel">⚡</span>
                    <div class="mobile-charge-bar">
                        <div class="mobile-charge-fill" id="mobileChargeBar" style="width: 100%;"></div>
                    </div>
                </div>
                <button id="mobilePauseBtn" class="mobile-stat" style="cursor: pointer;">
                    ||
                </button>
            </div>
        </div>

        <div id="mobileControls-area">
            <div class="touch-zone-hint">
                TAP TO FIRE • DRAG TO MOVE
                <span>Hold for auto-fire</span>
            </div>
            <div id="mobileFactContainer">
                <div class="mobile-fact-label">DID YOU KNOW?</div>
                <div id="mobileFactDisplay">A single utility-scale battery can replace a 50MW gas peaker plant.</div>
            </div>
        </div>

        <div id="sidePanel">
            <div class="panel-section">
                <div class="panel-title">STATUS</div>
                <div class="stat-row">
                    <span class="stat-label">SCORE</span>
                    <span class="stat-value" id="scoreDisplay">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">WAVE</span>
                    <span class="stat-value" id="waveDisplay">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ENEMIES</span>
                    <span class="stat-value" id="enemyCount">0 / 5</span>
                </div>
                <div style="margin-top: 10px;">
                    <span class="stat-label" style="font-size: 10px;">BATTERY CHARGE</span>
                    <div class="charge-bar-container">
                        <div class="charge-bar" id="chargeBar" style="width: 100%;"></div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">ENERGY IMPACT</div>
                <div class="energy-stat">
                    <span class="stat-label">MW DISPATCHED</span>
                    <span class="stat-value" id="mwDisplay">0</span>
                </div>
                <div class="energy-stat">
                    <span class="stat-label">CO2 AVOIDED</span>
                    <span class="stat-value" id="co2Display">0 kg</span>
                </div>
                <div class="energy-stat">
                    <span class="stat-label">TURBINES RETIRED</span>
                    <span class="stat-value" id="turbinesDisplay">0</span>
                </div>
                <div class="energy-stat">
                    <span class="stat-label">HOMES POWERED</span>
                    <span class="stat-value" id="homesDisplay">0</span>
                </div>
            </div>

            <div class="panel-section" style="margin-top: auto; font-size: 9px; color: #555; line-height: 1.5;">
                <div class="panel-title" style="color: #444;">DID YOU KNOW?</div>
                <p id="factDisplay">A single utility-scale battery can replace a 50MW gas peaker plant.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Mobile detection and scaling
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
                         ('ontouchstart' in window) ||
                         (navigator.maxTouchPoints > 0);
        let scaleFactor = 1;
        let canvasScale = 1;
        const baseWidth = 700;
        const baseHeight = 600;

        // Mobile-specific settings
        if (isMobile) {
            scaleFactor = 0.75; // Objects 25% smaller on mobile
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('desktopControls').style.display = 'none';
            document.getElementById('mobileHUD').style.display = 'flex';
        }

        // Touch control state
        let touchActive = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let touchDragX = 0; // Movement direction -1 to 1
        let touchDragY = 0;
        const touchIndicator = document.getElementById('touchIndicator');

        // Mobile control elements
        const mobileControlsArea = document.getElementById('mobileControls-area');

        // Resize canvas for mobile
        function resizeCanvas() {
            if (isMobile) {
                // Canvas will fill container via CSS, calculate scale for coordinate mapping
                const rect = canvas.getBoundingClientRect();
                canvasScale = rect.width / baseWidth;
            }
        }

        // Get touch position relative to canvas
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (touch.clientX - rect.left) / canvasScale,
                y: (touch.clientY - rect.top) / canvasScale
            };
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // Game State
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let wave = 1;
        let batteryCharge = 100;

        // Energy Metrics
        let mwGenerated = 0;
        let co2Avoided = 0;
        let homesPowered = 0;
        let turbinesRetired = 0;

        // Hook for Firebase integration (will be set by Firebase module)
        window.onGameOver = null;

        // Mouse position for aiming
        let mouseX = canvas.width / 2;
        let mouseY = 0;

        // Player
        const player = {
            x: 350,
            y: 300,
            width: Math.floor(48 * scaleFactor),
            height: Math.floor(64 * scaleFactor),
            speed: 4.5,
            dx: 0,
            dy: 0,
            angle: -Math.PI / 2,
            chargeRate: 0.4,
            maxCharge: 100
        };

        // Projectiles
        let projectiles = [];
        const projectileSpeed = 12;
        const projectileCost = 8;
        let canShoot = true;
        let shootCooldown = 150; // ms
        let lastShotTime = 0;

        // Enemies
        let enemies = [];
        let enemySpawnTimer = 0;
        let enemySpawnRate = 90;
        let enemiesPerWave = 5;
        let enemiesSpawnedThisWave = 0;
        let enemiesDefeatedThisWave = 0;
        let waveComplete = false;
        let waveTransitionTimer = 0;

        // High Wind Period & Wind Turbine Collectible
        let highWindActive = false;
        let highWindTimer = 0;
        let highWindDuration = 300; // frames (~5 seconds)
        let highWindStartFrame = 180; // Start high wind after 3 seconds into wave
        let windTurbine = null; // Collectible wind turbine
        let windTurbineCollected = false;

        // Spread Shot Power-up
        let spreadShotActive = false;
        let spreadShotTimer = 0;
        let spreadShotDuration = 480; // frames (~8 seconds)
        let spreadShotAngle = Math.PI / 6; // 30 degree spread

        // Boss Coal Power Plant
        let boss = null;
        let bossSpawned = false;
        let enemyProjectiles = []; // Projectiles fired by boss

        // Particles
        let particles = [];

        // Input
        const keys = {};

        // Energy facts
        const energyFacts = [
            "A single utility-scale battery can replace a 50MW gas peaker plant.",
            "Battery storage can respond to grid demands in milliseconds vs minutes for gas.",
            "The average gas turbine emits 400kg of CO2 per MWh generated.",
            "Battery costs have fallen 90% since 2010.",
            "California's grid is now 30% powered by batteries during peak hours.",
            "One 100MW battery can power 25,000 homes for 4 hours.",
            "Gas peaker plants often run less than 10% of the year.",
            "Batteries provide grid stability by balancing supply and demand instantly."
        ];
        let currentFact = 0;

        // Drawing functions
        function drawPixelRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }

        function drawBattery(x, y, charge, angle) {
            const s = scaleFactor;
            ctx.save();
            ctx.translate(x + 24 * s, y + 32 * s);

            // Draw aim direction indicator
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * 60 * s, Math.sin(angle) * 60 * s);
            ctx.stroke();

            // Aiming reticle
            const reticleX = Math.cos(angle) * 55 * s;
            const reticleY = Math.sin(angle) * 55 * s;
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.6)';
            ctx.beginPath();
            ctx.arc(reticleX, reticleY, 8 * s, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(reticleX - 12 * s, reticleY);
            ctx.lineTo(reticleX + 12 * s, reticleY);
            ctx.moveTo(reticleX, reticleY - 12 * s);
            ctx.lineTo(reticleX, reticleY + 12 * s);
            ctx.stroke();

            ctx.restore();

            // Battery body
            drawPixelRect(x, y + 8 * s, 48 * s, 56 * s, '#1a1a2e');
            drawPixelRect(x + 2 * s, y + 10 * s, 44 * s, 52 * s, '#16213e');

            // Terminal
            drawPixelRect(x + 16 * s, y, 16 * s, 10 * s, '#4a4a6a');
            drawPixelRect(x + 18 * s, y + 2 * s, 12 * s, 6 * s, '#6a6a8a');

            // Charge level
            const chargeHeight = Math.floor((charge / 100) * 44 * s);
            const chargeColor = charge > 60 ? '#00ff88' : charge > 30 ? '#ffaa00' : '#ff4444';
            drawPixelRect(x + 6 * s, y + 14 * s + (44 * s - chargeHeight), 36 * s, chargeHeight, chargeColor);

            // Segments
            for (let i = 0; i < 4; i++) {
                drawPixelRect(x + 4 * s, y + 14 * s + i * 11 * s, 40 * s, 2 * s, '#0a0a0a');
            }

            // Lightning bolt
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x + 28 * s, y + 20 * s);
            ctx.lineTo(x + 20 * s, y + 36 * s);
            ctx.lineTo(x + 24 * s, y + 36 * s);
            ctx.lineTo(x + 20 * s, y + 52 * s);
            ctx.lineTo(x + 32 * s, y + 32 * s);
            ctx.lineTo(x + 26 * s, y + 32 * s);
            ctx.closePath();
            ctx.fill();

            // Glow
            ctx.shadowColor = chargeColor;
            ctx.shadowBlur = 20 * s;
            drawPixelRect(x + 6 * s, y + 14 * s + (44 * s - chargeHeight), 36 * s, chargeHeight, chargeColor);
            ctx.shadowBlur = 0;

            // Shield effect when low charge
            if (charge < 20) {
                ctx.strokeStyle = `rgba(255, 68, 68, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 4 * s, y - 4 * s, 56 * s, 72 * s);
            }
        }

        function drawGasTurbine(x, y, health, maxHealth) {
            const s = scaleFactor;
            const damageRatio = health / maxHealth;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 24 * s, y + 62 * s, 20 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Base
            drawPixelRect(x + 12 * s, y + 48 * s, 24 * s, 8 * s, '#4a3a2a');
            drawPixelRect(x + 8 * s, y + 54 * s, 32 * s, 6 * s, '#5a4a3a');

            // Body - show damage
            const bodyColor = damageRatio > 0.5 ? '#6a6a7a' : '#5a4a4a';
            drawPixelRect(x + 8 * s, y + 16 * s, 32 * s, 34 * s, bodyColor);
            drawPixelRect(x + 10 * s, y + 18 * s, 28 * s, 30 * s, damageRatio > 0.5 ? '#8a8a9a' : '#7a6a6a');

            // Damage sparks
            if (damageRatio < 0.5) {
                if (Math.random() > 0.7) {
                    ctx.fillStyle = '#ffaa44';
                    ctx.fillRect(x + 10 * s + Math.random() * 28 * s, y + 18 * s + Math.random() * 30 * s, 3 * s, 3 * s);
                }
            }

            // Stack
            drawPixelRect(x + 18 * s, y, 12 * s, 18 * s, '#5a5a6a');
            drawPixelRect(x + 20 * s, y + 2 * s, 8 * s, 14 * s, '#7a7a8a');

            // Smoke
            const smokeIntensity = damageRatio;
            const time = Date.now() / 200;
            ctx.globalAlpha = 0.4 + smokeIntensity * 0.3;
            for (let i = 0; i < 3; i++) {
                const offset = Math.sin(time + i) * 3 * s;
                const yOff = (-8 - i * 8) * s;
                const size = (6 + i * 2) * s;
                ctx.fillStyle = `rgb(${100 + i * 30}, ${100 + i * 30}, ${100 + i * 30})`;
                drawPixelRect(x + 20 * s + offset, y + yOff, size, size, ctx.fillStyle);
            }
            ctx.globalAlpha = 1;

            // Spinning blades
            ctx.save();
            ctx.translate(x + 24 * s, y + 32 * s);
            const rotation = Date.now() / (100 + (1 - damageRatio) * 200);
            ctx.rotate(rotation);
            for (let i = 0; i < 3; i++) {
                ctx.rotate(Math.PI * 2 / 3);
                drawPixelRect(-2 * s, -12 * s, 4 * s, 12 * s, '#3a3a4a');
            }
            ctx.restore();

            // Health bar
            const barWidth = 40 * s;
            drawPixelRect(x + 4 * s, y - 8 * s, barWidth, 6 * s, '#222');
            drawPixelRect(x + 5 * s, y - 7 * s, (barWidth - 2 * s) * damageRatio, 4 * s,
                damageRatio > 0.6 ? '#ff6644' : damageRatio > 0.3 ? '#ff4422' : '#ff2222');

            // CO2 emission indicator
            ctx.fillStyle = '#ff6644';
            ctx.font = `bold ${Math.floor(9 * s)}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText('CO2', x + 24 * s, y - 12 * s);
            ctx.textAlign = 'left';
        }

        // Draw collectible wind turbine (green/friendly)
        function drawWindTurbine(x, y) {
            const s = scaleFactor;
            const time = Date.now() / 50; // Fast spin for high wind

            // Glow effect
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 20 * s;

            // Tower
            drawPixelRect(x + 18 * s, y + 20 * s, 12 * s, 40 * s, '#88ccaa');
            drawPixelRect(x + 20 * s, y + 22 * s, 8 * s, 36 * s, '#aaddbb');

            // Base
            drawPixelRect(x + 12 * s, y + 56 * s, 24 * s, 8 * s, '#669977');

            // Nacelle (hub)
            ctx.fillStyle = '#ccffdd';
            ctx.beginPath();
            ctx.arc(x + 24 * s, y + 20 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            // Spinning blades (fast for high wind!)
            ctx.save();
            ctx.translate(x + 24 * s, y + 20 * s);
            ctx.rotate(time);
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 3; i++) {
                ctx.rotate(Math.PI * 2 / 3);
                // Blade
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4 * s, -28 * s);
                ctx.lineTo(0, -30 * s);
                ctx.lineTo(4 * s, -28 * s);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();

            ctx.shadowBlur = 0;

            // "WIND" label
            ctx.fillStyle = '#00ff88';
            ctx.font = `bold ${Math.floor(10 * s)}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText('WIND', x + 24 * s, y - 5 * s);
            ctx.textAlign = 'left';

            // Pulsing collect indicator
            const pulse = 0.5 + Math.sin(Date.now() / 150) * 0.3;
            ctx.strokeStyle = `rgba(0, 255, 136, ${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 24 * s, y + 32 * s, 35 * s + Math.sin(Date.now() / 200) * 5, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw Boss Coal Power Plant
        function drawCoalPlant(x, y, health, maxHealth) {
            const s = scaleFactor;
            const damageRatio = health / maxHealth;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 40 * s, y + 95 * s, 35 * s, 10 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main building
            drawPixelRect(x + 10 * s, y + 40 * s, 60 * s, 50 * s, '#3a3a4a');
            drawPixelRect(x + 12 * s, y + 42 * s, 56 * s, 46 * s, '#4a4a5a');

            // Furnace glow
            const glowIntensity = 0.5 + Math.sin(Date.now() / 100) * 0.3;
            ctx.fillStyle = `rgba(255, ${100 + Math.floor(glowIntensity * 50)}, 0, ${glowIntensity})`;
            drawPixelRect(x + 20 * s, y + 60 * s, 40 * s, 25 * s, ctx.fillStyle);

            // Smoke stacks (two big ones)
            drawPixelRect(x + 15 * s, y + 5 * s, 18 * s, 40 * s, '#5a5a6a');
            drawPixelRect(x + 47 * s, y + 5 * s, 18 * s, 40 * s, '#5a5a6a');
            drawPixelRect(x + 17 * s, y + 7 * s, 14 * s, 36 * s, '#6a6a7a');
            drawPixelRect(x + 49 * s, y + 7 * s, 14 * s, 36 * s, '#6a6a7a');

            // Heavy black smoke
            const smokeTime = Date.now() / 150;
            ctx.globalAlpha = 0.6;
            for (let stack = 0; stack < 2; stack++) {
                const stackX = stack === 0 ? x + 24 * s : x + 56 * s;
                for (let i = 0; i < 5; i++) {
                    const offset = Math.sin(smokeTime + i + stack) * 8 * s;
                    const yOff = (-10 - i * 12) * s;
                    const size = (10 + i * 4) * s;
                    ctx.fillStyle = `rgb(${40 + i * 15}, ${40 + i * 15}, ${40 + i * 15})`;
                    ctx.beginPath();
                    ctx.arc(stackX + offset, y + yOff, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // Conveyor belt with coal
            drawPixelRect(x - 10 * s, y + 75 * s, 30 * s, 8 * s, '#2a2a2a');
            for (let i = 0; i < 3; i++) {
                drawPixelRect(x - 5 * s + i * 8 * s, y + 72 * s, 6 * s, 6 * s, '#1a1a1a');
            }

            // Warning lights (flash when about to fire)
            if (Math.floor(Date.now() / 300) % 2 === 0) {
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(x + 24 * s, y + 45 * s, 4 * s, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 56 * s, y + 45 * s, 4 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            // Health bar (larger for boss)
            const barWidth = 70 * s;
            drawPixelRect(x + 5 * s, y - 15 * s, barWidth, 10 * s, '#222');
            drawPixelRect(x + 6 * s, y - 14 * s, (barWidth - 2 * s) * damageRatio, 8 * s,
                damageRatio > 0.6 ? '#ff6644' : damageRatio > 0.3 ? '#ff4422' : '#ff2222');

            // Boss label
            ctx.fillStyle = '#ff4444';
            ctx.font = `bold ${Math.floor(11 * s)}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText('COAL BOSS', x + 40 * s, y - 20 * s);
            ctx.font = `${Math.floor(8 * s)}px Courier New`;
            ctx.fillText('DEMAND SPIKE', x + 40 * s, y + 105 * s);
            ctx.textAlign = 'left';

            // Damage sparks
            if (damageRatio < 0.5) {
                for (let i = 0; i < 2; i++) {
                    if (Math.random() > 0.6) {
                        ctx.fillStyle = '#ffaa44';
                        ctx.fillRect(x + 15 * s + Math.random() * 50 * s, y + 40 * s + Math.random() * 40 * s, 4 * s, 4 * s);
                    }
                }
            }
        }

        // Draw enemy projectile (coal/fire ball)
        function drawEnemyProjectile(x, y) {
            const s = scaleFactor;

            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 10 * s;

            // Fire ball
            ctx.fillStyle = '#ff6622';
            ctx.beginPath();
            ctx.arc(x, y, 8 * s, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffaa44';
            ctx.beginPath();
            ctx.arc(x, y, 5 * s, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ffcc66';
            ctx.beginPath();
            ctx.arc(x, y, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        function drawProjectile(x, y, angle) {
            const s = scaleFactor;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2);

            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15 * s;

            // Electric bolt shape
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(0, -10 * s);
            ctx.lineTo(-4 * s, 0);
            ctx.lineTo(-2 * s, 0);
            ctx.lineTo(-3 * s, 10 * s);
            ctx.lineTo(3 * s, 2 * s);
            ctx.lineTo(1 * s, 2 * s);
            ctx.lineTo(4 * s, -6 * s);
            ctx.closePath();
            ctx.fill();

            // Glow core
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(0, 0, 3 * s, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();

            // Trail particles
            if (Math.random() > 0.5) {
                particles.push({
                    x: x - Math.cos(angle) * 10 * s,
                    y: y - Math.sin(angle) * 10 * s,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 15,
                    maxLife: 15,
                    size: 3 * s,
                    color: Math.random() > 0.5 ? '#00ffff' : '#88ffff'
                });
            }
        }

        function createExplosion(x, y, type) {
            const s = scaleFactor;
            const count = type === 'big' ? 20 : type === 'wind' ? 25 : 10;
            const colors = type === 'electric' ? ['#00ffff', '#88ffff', '#ffffff', '#00ff88'] :
                          type === 'enemy' ? ['#ff4400', '#ff6622', '#ffaa44', '#ff2200'] :
                          type === 'wind' ? ['#00ff88', '#88ffcc', '#ffffff', '#44ffaa', '#00ffaa'] :
                          ['#ff8844', '#ffaa44', '#ffcc44', '#ff6622', '#ffffff'];

            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = (2 + Math.random() * 4) * s;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    size: (3 + Math.random() * 5) * s,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }

            // Screen shake effect (less intense on mobile)
            if (type === 'big') {
                const shake = isMobile ? 4 : 8;
                canvas.style.transform = `translate(${(Math.random() - 0.5) * shake}px, ${(Math.random() - 0.5) * shake}px)`;
                setTimeout(() => canvas.style.transform = '', 50);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.size *= 0.97;

                if (p.life <= 0 || p.size < 0.5) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 5;
                drawPixelRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size, p.color);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function spawnEnemy() {
            const s = scaleFactor;
            const side = Math.floor(Math.random() * 4);
            const margin = 60;
            const enemyW = Math.floor(48 * s);
            const enemyH = Math.floor(60 * s);
            let x, y;

            switch(side) {
                case 0: // Top
                    x = margin + Math.random() * (canvas.width - margin * 2 - enemyW);
                    y = -enemyH;
                    break;
                case 1: // Right
                    x = canvas.width + 10;
                    y = margin + Math.random() * (canvas.height - margin * 2 - enemyH);
                    break;
                case 2: // Bottom
                    x = margin + Math.random() * (canvas.width - margin * 2 - enemyW);
                    y = canvas.height + 10;
                    break;
                case 3: // Left
                    x = -enemyW - 10;
                    y = margin + Math.random() * (canvas.height - margin * 2 - enemyH);
                    break;
            }

            const baseHealth = 40 + wave * 15;
            const speedMult = 1 + wave * 0.08;

            enemies.push({
                x: x,
                y: y,
                width: enemyW,
                height: enemyH,
                speed: (0.8 + Math.random() * 0.4) * speedMult,
                health: baseHealth,
                maxHealth: baseHealth,
                wobble: Math.random() * Math.PI * 2,
                wobbleSpeed: 0.02 + Math.random() * 0.02
            });
        }

        // Spawn collectible wind turbine
        function spawnWindTurbine() {
            const s = scaleFactor;
            const turbineW = Math.floor(48 * s);
            const turbineH = Math.floor(64 * s);

            // Spawn in a random position away from edges
            const margin = 80;
            windTurbine = {
                x: margin + Math.random() * (canvas.width - margin * 2 - turbineW),
                y: margin + Math.random() * (canvas.height - margin * 2 - turbineH),
                width: turbineW,
                height: turbineH
            };
        }

        // Spawn boss coal power plant
        function spawnBoss() {
            const s = scaleFactor;
            const bossW = Math.floor(80 * s);
            const bossH = Math.floor(100 * s);

            // Spawn from a random edge
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: // Top
                    x = canvas.width / 2 - bossW / 2;
                    y = -bossH;
                    break;
                case 1: // Right
                    x = canvas.width + 10;
                    y = canvas.height / 2 - bossH / 2;
                    break;
                case 2: // Bottom
                    x = canvas.width / 2 - bossW / 2;
                    y = canvas.height + 10;
                    break;
                case 3: // Left
                    x = -bossW - 10;
                    y = canvas.height / 2 - bossH / 2;
                    break;
            }

            const bossHealth = 200 + wave * 50;

            boss = {
                x: x,
                y: y,
                width: bossW,
                height: bossH,
                speed: 1.2,
                health: bossHealth,
                maxHealth: bossHealth,
                fireTimer: 0,
                fireRate: 90, // Frames between shots
                targetX: canvas.width / 2,
                targetY: canvas.height / 2
            };
            bossSpawned = true;
        }

        // Boss fires a projectile at the player
        function bossFireProjectile() {
            if (!boss) return;

            const startX = boss.x + boss.width / 2;
            const startY = boss.y + boss.height / 2;
            const angle = Math.atan2(
                player.y + player.height / 2 - startY,
                player.x + player.width / 2 - startX
            );

            enemyProjectiles.push({
                x: startX,
                y: startY,
                vx: Math.cos(angle) * 5,
                vy: Math.sin(angle) * 5,
                radius: 8 * scaleFactor
            });

            // Fire effect
            createExplosion(startX, startY, 'enemy');
        }

        function fireProjectile() {
            const now = Date.now();
            if (batteryCharge >= projectileCost && now - lastShotTime > shootCooldown) {
                batteryCharge -= projectileCost;
                lastShotTime = now;

                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;

                if (spreadShotActive) {
                    // Fire 5 projectiles in a spread pattern
                    const spreadAngles = [-spreadShotAngle, -spreadShotAngle/2, 0, spreadShotAngle/2, spreadShotAngle];
                    spreadAngles.forEach(offset => {
                        const angle = player.angle + offset;
                        projectiles.push({
                            x: startX,
                            y: startY,
                            angle: angle,
                            vx: Math.cos(angle) * projectileSpeed,
                            vy: Math.sin(angle) * projectileSpeed,
                            width: 12,
                            height: 20
                        });
                    });
                    // Bigger muzzle flash for spread shot
                    createExplosion(startX + Math.cos(player.angle) * 20,
                                   startY + Math.sin(player.angle) * 20, 'big');
                } else {
                    // Normal single shot
                    projectiles.push({
                        x: startX,
                        y: startY,
                        angle: player.angle,
                        vx: Math.cos(player.angle) * projectileSpeed,
                        vy: Math.sin(player.angle) * projectileSpeed,
                        width: 12,
                        height: 20
                    });
                    createExplosion(startX + Math.cos(player.angle) * 20,
                                   startY + Math.sin(player.angle) * 20, 'electric');
                }
            }
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function pointInRect(px, py, rect) {
            return px >= rect.x && px <= rect.x + rect.width &&
                   py >= rect.y && py <= rect.y + rect.height;
        }

        function updateMetricsDisplay() {
            document.getElementById('scoreDisplay').textContent = score.toLocaleString();
            document.getElementById('waveDisplay').textContent = wave;
            document.getElementById('enemyCount').textContent = `${enemiesDefeatedThisWave} / ${enemiesPerWave}`;
            document.getElementById('chargeBar').style.width = batteryCharge + '%';
            document.getElementById('chargeBar').style.background =
                batteryCharge > 60 ? 'linear-gradient(90deg, #00ff88, #88ffcc)' :
                batteryCharge > 30 ? 'linear-gradient(90deg, #ffaa00, #ffcc44)' :
                'linear-gradient(90deg, #ff4444, #ff6666)';

            document.getElementById('mwDisplay').textContent = mwGenerated.toFixed(1);
            document.getElementById('co2Display').textContent = Math.floor(co2Avoided).toLocaleString() + ' kg';
            document.getElementById('turbinesDisplay').textContent = turbinesRetired;
            document.getElementById('homesDisplay').textContent = homesPowered.toLocaleString();

            // Update mobile HUD
            if (isMobile) {
                document.getElementById('mobileScore').textContent = score.toLocaleString();
                document.getElementById('mobileWave').textContent = wave;
                const mobileChargeBar = document.getElementById('mobileChargeBar');
                mobileChargeBar.style.width = batteryCharge + '%';
                mobileChargeBar.style.background =
                    batteryCharge > 60 ? '#00ff88' :
                    batteryCharge > 30 ? '#ffaa00' : '#ff4444';
            }
        }

        function nextWave() {
            wave++;
            enemiesPerWave = Math.min(5 + wave * 2, 25);
            enemySpawnRate = Math.max(50, 90 - wave * 5);
            enemiesSpawnedThisWave = 0;
            enemiesDefeatedThisWave = 0;
            waveComplete = false;

            // Reset high wind / power-up state for new wave
            highWindActive = false;
            highWindTimer = 0;
            windTurbine = null;
            windTurbineCollected = false;
            spreadShotActive = false;
            spreadShotTimer = 0;
            // Note: boss persists between waves if not killed

            // Bonus
            batteryCharge = Math.min(100, batteryCharge + 25);
            score += wave * 500;

            // New fact
            currentFact = (currentFact + 1) % energyFacts.length;
            document.getElementById('factDisplay').textContent = energyFacts[currentFact];

            // Update mobile fact display too
            const mobileFact = document.getElementById('mobileFactDisplay');
            if (mobileFact) {
                mobileFact.textContent = energyFacts[currentFact];
            }
        }

        function update() {
            if (!gameRunning || gamePaused) return;

            // Player movement
            player.dx = 0;
            player.dy = 0;

            // Keyboard movement
            if (keys['ArrowLeft'] || keys['KeyA']) player.dx = -player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.dx = player.speed;
            if (keys['ArrowUp'] || keys['KeyW']) player.dy = -player.speed;
            if (keys['ArrowDown'] || keys['KeyS']) player.dy = player.speed;

            // Touch drag movement for mobile
            if (isMobile && touchActive && (Math.abs(touchDragX) > 0.1 || Math.abs(touchDragY) > 0.1)) {
                player.dx = touchDragX * player.speed;
                player.dy = touchDragY * player.speed;

                // Update aim direction based on movement
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                mouseX = centerX + touchDragX * 100;
                mouseY = centerY + touchDragY * 100;
            }

            if (player.dx !== 0 && player.dy !== 0) {
                player.dx *= 0.707;
                player.dy *= 0.707;
            }

            player.x += player.dx;
            player.y += player.dy;

            // Bounds
            player.x = Math.max(10, Math.min(canvas.width - player.width - 10, player.x));
            player.y = Math.max(10, Math.min(canvas.height - player.height - 10, player.y));

            // Aim toward mouse
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;
            player.angle = Math.atan2(mouseY - centerY, mouseX - centerX);

            // Recharge
            if (batteryCharge < player.maxCharge) {
                batteryCharge += player.chargeRate;
                mwGenerated += 0.002;
            }

            // Continuous fire while holding
            if (keys['Space']) {
                fireProjectile();
            }

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;

                if (p.x < -50 || p.x > canvas.width + 50 ||
                    p.y < -50 || p.y > canvas.height + 50) {
                    projectiles.splice(i, 1);
                }
            }

            // High Wind Period Logic
            if (!waveComplete && !highWindActive && !windTurbineCollected) {
                highWindTimer++;
                if (highWindTimer >= highWindStartFrame && highWindTimer < highWindStartFrame + highWindDuration) {
                    highWindActive = true;
                    // Spawn wind turbine if not already present
                    if (!windTurbine) {
                        spawnWindTurbine();
                    }
                }
            }

            // Check if high wind period ended without collection
            if (highWindActive && highWindTimer >= highWindStartFrame + highWindDuration) {
                highWindActive = false;
                windTurbine = null; // Remove uncollected turbine
            }

            // Wind Turbine Collection
            if (windTurbine && !windTurbineCollected) {
                const hitPadding = 5 * scaleFactor;
                if (checkCollision({
                    x: player.x + hitPadding,
                    y: player.y + hitPadding,
                    width: player.width - hitPadding * 2,
                    height: player.height - hitPadding * 2
                }, windTurbine)) {
                    // Collected!
                    windTurbineCollected = true;
                    windTurbine = null;
                    highWindActive = false;
                    spreadShotActive = true;
                    spreadShotTimer = 0;

                    // Big wind explosion effect
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 'wind');
                    score += 500;
                    mwGenerated += 10; // Wind power bonus

                    // Spawn the boss!
                    if (!bossSpawned) {
                        spawnBoss();
                    }
                }
            }

            // Spread Shot Timer
            if (spreadShotActive) {
                spreadShotTimer++;
                if (spreadShotTimer >= spreadShotDuration) {
                    spreadShotActive = false;
                }
            }

            // Boss Update
            if (boss) {
                // Move boss toward a target position (slowly circles around)
                boss.targetX = canvas.width / 2 + Math.cos(Date.now() / 2000) * 200;
                boss.targetY = canvas.height / 2 + Math.sin(Date.now() / 2000) * 150;

                const bossAngle = Math.atan2(boss.targetY - boss.y - boss.height/2, boss.targetX - boss.x - boss.width/2);
                boss.x += Math.cos(bossAngle) * boss.speed;
                boss.y += Math.sin(bossAngle) * boss.speed;

                // Keep boss on screen
                boss.x = Math.max(10, Math.min(canvas.width - boss.width - 10, boss.x));
                boss.y = Math.max(10, Math.min(canvas.height - boss.height - 10, boss.y));

                // Boss fires at player
                boss.fireTimer++;
                if (boss.fireTimer >= boss.fireRate) {
                    bossFireProjectile();
                    boss.fireTimer = 0;
                }

                // Boss collision with player
                const hitPadding = 10 * scaleFactor;
                if (checkCollision({
                    x: player.x + hitPadding,
                    y: player.y + hitPadding,
                    width: player.width - hitPadding * 2,
                    height: player.height - hitPadding * 2
                }, boss)) {
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 'big');
                    gameOver();
                    return;
                }

                // Boss collision with projectiles
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const p = projectiles[j];
                    const projW = 12 * scaleFactor;
                    const projH = 20 * scaleFactor;
                    if (checkCollision({
                        x: p.x - projW / 2,
                        y: p.y - projH / 2,
                        width: projW,
                        height: projH
                    }, boss)) {
                        boss.health -= 15;
                        createExplosion(p.x, p.y, 'electric');
                        projectiles.splice(j, 1);

                        if (boss.health <= 0) {
                            createExplosion(boss.x + boss.width/2, boss.y + boss.height/2, 'big');
                            createExplosion(boss.x + boss.width/4, boss.y + boss.height/4, 'big');
                            createExplosion(boss.x + boss.width*3/4, boss.y + boss.height*3/4, 'big');
                            score += 2000 + wave * 500;
                            co2Avoided += 2000;
                            turbinesRetired += 5;
                            homesPowered = Math.floor(turbinesRetired * 500);
                            mwGenerated += 25;
                            boss = null;
                            bossSpawned = false;
                        }
                        break;
                    }
                }
            }

            // Enemy Projectiles Update
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                ep.x += ep.vx;
                ep.y += ep.vy;

                // Remove if off screen
                if (ep.x < -50 || ep.x > canvas.width + 50 ||
                    ep.y < -50 || ep.y > canvas.height + 50) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                // Collision with player
                const hitPadding = 8 * scaleFactor;
                const playerRect = {
                    x: player.x + hitPadding,
                    y: player.y + hitPadding,
                    width: player.width - hitPadding * 2,
                    height: player.height - hitPadding * 2
                };

                const dist = Math.sqrt(
                    Math.pow(ep.x - (playerRect.x + playerRect.width/2), 2) +
                    Math.pow(ep.y - (playerRect.y + playerRect.height/2), 2)
                );

                if (dist < ep.radius + Math.min(playerRect.width, playerRect.height) / 2) {
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 'enemy');
                    gameOver();
                    return;
                }
            }

            // Wave transition
            if (waveComplete) {
                waveTransitionTimer++;
                if (waveTransitionTimer > 120) {
                    nextWave();
                    waveTransitionTimer = 0;
                }
                return;
            }

            // Spawn enemies
            enemySpawnTimer++;
            if (enemySpawnTimer >= enemySpawnRate && enemiesSpawnedThisWave < enemiesPerWave) {
                spawnEnemy();
                enemiesSpawnedThisWave++;
                enemySpawnTimer = 0;
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Move toward player with wobble
                enemy.wobble += enemy.wobbleSpeed;
                const angleToPlayer = Math.atan2(
                    player.y + player.height/2 - enemy.y - enemy.height/2,
                    player.x + player.width/2 - enemy.x - enemy.width/2
                );

                enemy.x += Math.cos(angleToPlayer) * enemy.speed + Math.sin(enemy.wobble) * 0.5;
                enemy.y += Math.sin(angleToPlayer) * enemy.speed + Math.cos(enemy.wobble) * 0.5;

                // Keep enemies on screen (with margin)
                const margin = 30;
                enemy.x = Math.max(-margin, Math.min(canvas.width - enemy.width + margin, enemy.x));
                enemy.y = Math.max(-margin, Math.min(canvas.height - enemy.height + margin, enemy.y));

                // Collision with player
                const hitPadding = 8 * scaleFactor;
                if (checkCollision({
                    x: player.x + hitPadding,
                    y: player.y + hitPadding,
                    width: player.width - hitPadding * 2,
                    height: player.height - hitPadding * 2
                }, enemy)) {
                    createExplosion(player.x + player.width/2, player.y + player.height/2, 'big');
                    gameOver();
                    return;
                }

                // Collision with projectiles
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const p = projectiles[j];
                    const projW = 12 * scaleFactor;
                    const projH = 20 * scaleFactor;
                    if (checkCollision({
                        x: p.x - projW / 2,
                        y: p.y - projH / 2,
                        width: projW,
                        height: projH
                    }, enemy)) {
                        enemy.health -= 20;
                        createExplosion(p.x, p.y, 'electric');
                        projectiles.splice(j, 1);

                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 'big');
                            enemies.splice(i, 1);

                            score += 100 + wave * 50;
                            turbinesRetired++;
                            co2Avoided += 400;
                            homesPowered = Math.floor(turbinesRetired * 500);
                            mwGenerated += 2.5;

                            enemiesDefeatedThisWave++;

                            if (enemiesDefeatedThisWave >= enemiesPerWave && enemiesSpawnedThisWave >= enemiesPerWave) {
                                waveComplete = true;
                            }
                        }
                        break;
                    }
                }
            }

            updateParticles();
            updateMetricsDisplay();
        }

        function draw() {
            // Background
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#151525';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Particles (background layer)
            drawParticles();

            // Projectiles
            projectiles.forEach(p => {
                drawProjectile(p.x, p.y, p.angle);
            });

            // Enemies
            enemies.forEach(enemy => {
                drawGasTurbine(enemy.x, enemy.y, enemy.health, enemy.maxHealth);
            });

            // Wind Turbine Collectible
            if (windTurbine) {
                drawWindTurbine(windTurbine.x, windTurbine.y);
            }

            // Boss Coal Plant
            if (boss) {
                drawCoalPlant(boss.x, boss.y, boss.health, boss.maxHealth);
            }

            // Enemy Projectiles
            enemyProjectiles.forEach(ep => {
                drawEnemyProjectile(ep.x, ep.y);
            });

            // Player
            drawBattery(player.x, player.y, batteryCharge, player.angle);

            // High Wind Indicator
            if (highWindActive && !windTurbineCollected) {
                const pulse = 0.6 + Math.sin(Date.now() / 200) * 0.3;
                ctx.strokeStyle = `rgba(0, 255, 136, ${pulse})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${isMobile ? 14 : 18}px Courier New`;
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;
                ctx.fillText('⚡ HIGH WIND - GRAB THE TURBINE! ⚡', canvas.width / 2, 30);
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }

            // Spread Shot Active Indicator
            if (spreadShotActive) {
                const remainingPercent = 1 - (spreadShotTimer / spreadShotDuration);
                const barWidth = canvas.width - 20;

                // Power-up bar at top
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(10, 40, barWidth, 12);
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(10, 40, barWidth * remainingPercent, 12);
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#00ffff';
                ctx.font = `bold ${isMobile ? 10 : 12}px Courier New`;
                ctx.textAlign = 'center';
                ctx.fillText('SPREAD SHOT ACTIVE', canvas.width / 2, 50);
                ctx.textAlign = 'left';

                // Demand spike warning
                if (boss) {
                    const warnPulse = 0.5 + Math.sin(Date.now() / 100) * 0.4;
                    ctx.strokeStyle = `rgba(255, 68, 68, ${warnPulse})`;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);

                    ctx.fillStyle = '#ff4444';
                    ctx.font = `bold ${isMobile ? 12 : 14}px Courier New`;
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 10;
                    ctx.fillText('⚠ DEMAND SPIKE - COAL BOSS INCOMING! ⚠', canvas.width / 2, canvas.height - 15);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                }
            }

            // Wave complete banner
            if (waveComplete) {
                const bannerH = isMobile ? 80 : 120;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, canvas.height/2 - bannerH/2, canvas.width, bannerH);

                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${isMobile ? 20 : 28}px Courier New`;
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 20;
                ctx.fillText(`WAVE ${wave} COMPLETE!`, canvas.width / 2, canvas.height / 2 - 10);

                ctx.font = `${isMobile ? 11 : 14}px Courier New`;
                ctx.fillStyle = '#88ffcc';
                ctx.fillText(`+${wave * 500} bonus points | Battery recharged`, canvas.width / 2, canvas.height / 2 + 20);

                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }

            // Pause overlay
            if (gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ff88';
                ctx.font = `bold ${isMobile ? 28 : 36}px Courier New`;
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 20;
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

                ctx.font = `${isMobile ? 12 : 14}px Courier New`;
                ctx.fillText(isMobile ? 'Tap to Resume' : 'Press P to Resume', canvas.width / 2, canvas.height / 2 + 35);
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameRunning = true;
            gamePaused = false;
            score = 0;
            wave = 1;
            batteryCharge = 100;
            mwGenerated = 0;
            co2Avoided = 0;
            homesPowered = 0;
            turbinesRetired = 0;

            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height / 2 - player.height / 2;

            projectiles = [];
            enemies = [];
            particles = [];
            enemyProjectiles = [];

            enemySpawnTimer = 0;
            enemySpawnRate = 90;
            enemiesPerWave = 5;
            enemiesSpawnedThisWave = 0;
            enemiesDefeatedThisWave = 0;
            waveComplete = false;
            waveTransitionTimer = 0;

            // Reset high wind / power-up / boss state
            highWindActive = false;
            highWindTimer = 0;
            windTurbine = null;
            windTurbineCollected = false;
            spreadShotActive = false;
            spreadShotTimer = 0;
            boss = null;
            bossSpawned = false;

            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';

            updateMetricsDisplay();
        }

        async function gameOver() {
            gameRunning = false;

            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('finalWaves').textContent = wave - 1;
            document.getElementById('finalMW').textContent = mwGenerated.toFixed(1);
            document.getElementById('finalCO2').textContent = Math.floor(co2Avoided).toLocaleString();
            document.getElementById('finalTurbines').textContent = turbinesRetired;

            // Call Firebase hook if available (for scoreboard)
            if (window.onGameOver) {
                await window.onGameOver({
                    score: score,
                    wave: wave,
                    mwGenerated: mwGenerated,
                    co2Avoided: co2Avoided,
                    turbinesRetired: turbinesRetired
                });
            }

            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning && !gamePaused) {
                    fireProjectile();
                }
            }

            if (e.code === 'KeyP' && gameRunning) {
                gamePaused = !gamePaused;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning && !gamePaused) {
                fireProjectile();
            }
        });

        // Hold to fire
        let mouseHeld = false;
        canvas.addEventListener('mousedown', () => { mouseHeld = true; });
        canvas.addEventListener('mouseup', () => { mouseHeld = false; });
        canvas.addEventListener('mouseleave', () => { mouseHeld = false; });

        setInterval(() => {
            if (mouseHeld && gameRunning && !gamePaused) {
                fireProjectile();
            }
        }, shootCooldown);

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') e.preventDefault();
        });

        // Touch controls for mobile
        if (isMobile) {
            let touchId = null;
            const dragThreshold = 15; // Pixels before drag is registered

            if (mobileControlsArea) {
                mobileControlsArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length > 0 && touchId === null) {
                        const touch = e.touches[0];
                        touchId = touch.identifier;
                        touchActive = true;
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        touchCurrentX = touch.clientX;
                        touchCurrentY = touch.clientY;
                        touchDragX = 0;
                        touchDragY = 0;

                        // Fire immediately on touch
                        if (gameRunning && !gamePaused) {
                            fireProjectile();
                        }
                    }
                }, { passive: false });

                mobileControlsArea.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === touchId) {
                            const touch = e.touches[i];
                            touchCurrentX = touch.clientX;
                            touchCurrentY = touch.clientY;

                            // Calculate drag from start position
                            const dx = touchCurrentX - touchStartX;
                            const dy = touchCurrentY - touchStartY;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance > dragThreshold) {
                                // Normalize and clamp to -1 to 1
                                const maxDrag = 80; // Max drag distance for full speed
                                const normalizedDist = Math.min(distance, maxDrag) / maxDrag;
                                touchDragX = (dx / distance) * normalizedDist;
                                touchDragY = (dy / distance) * normalizedDist;
                            } else {
                                touchDragX = 0;
                                touchDragY = 0;
                            }
                            break;
                        }
                    }
                }, { passive: false });

                mobileControlsArea.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    let found = false;
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === touchId) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        touchActive = false;
                        touchId = null;
                        touchDragX = 0;
                        touchDragY = 0;
                    }
                }, { passive: false });

                mobileControlsArea.addEventListener('touchcancel', (e) => {
                    touchActive = false;
                    touchId = null;
                    touchDragX = 0;
                    touchDragY = 0;
                }, { passive: false });
            }

            // Auto-fire while touch is held
            setInterval(() => {
                if (touchActive && gameRunning && !gamePaused) {
                    fireProjectile();
                }
            }, shootCooldown);

            // Canvas tap to unpause
            canvas.addEventListener('touchstart', (e) => {
                if (gameRunning && gamePaused) {
                    e.preventDefault();
                    gamePaused = false;
                }
            }, { passive: false });

            // Mobile pause button
            const pauseBtn = document.getElementById('mobilePauseBtn');
            if (pauseBtn) {
                pauseBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (gameRunning) {
                        gamePaused = !gamePaused;
                    }
                }, { passive: false });
            }
        }

        // Start
        gameLoop();
    </script>

    <!-- Firebase Integration -->
    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";
        import { getDatabase, ref, get, set, query, orderByChild, limitToLast } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCly-__olSW31_CWI8ZywsbMke94Yn4n1M",
            authDomain: "battery-blaster.firebaseapp.com",
            databaseURL: "https://battery-blaster-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "battery-blaster",
            storageBucket: "battery-blaster.firebasestorage.app",
            messagingSenderId: "84791201877",
            appId: "1:84791201877:web:d2cab6990e259eb6f984dc",
            measurementId: "G-QXEL3F1EDW"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const database = getDatabase(app);

        // Player state
        let playerName = null;
        let scoreboardEnabled = false;

        // Create a sanitized key from player name (Firebase doesn't allow certain characters in keys)
        function sanitizeKey(name) {
            return name.toLowerCase().replace(/[.#$[\]]/g, '_').replace(/\s+/g, '_');
        }

        // Submit player name
        window.submitPlayerName = function() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();

            if (name.length > 0) {
                playerName = name;
                scoreboardEnabled = true;
                localStorage.setItem('batteryBlasterName', name);
            }

            document.getElementById('namePrompt').style.display = 'none';
        };

        // Skip name entry
        window.skipNameEntry = function() {
            playerName = null;
            scoreboardEnabled = false;
            document.getElementById('namePrompt').style.display = 'none';
        };

        // Check for saved name on load
        const savedName = localStorage.getItem('batteryBlasterName');
        if (savedName) {
            playerName = savedName;
            scoreboardEnabled = true;
            document.getElementById('namePrompt').style.display = 'none';
        }

        // Allow Enter key to submit name
        const nameInput = document.getElementById('playerNameInput');
        if (nameInput) {
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    window.submitPlayerName();
                }
            });
        }

        // Save or update high score in Firebase
        async function saveHighScore(name, newScore) {
            if (!scoreboardEnabled || !name) return;

            const playerKey = sanitizeKey(name);
            const playerRef = ref(database, 'scores/' + playerKey);

            try {
                // Get current high score for this player
                const snapshot = await get(playerRef);

                if (snapshot.exists()) {
                    const currentData = snapshot.val();
                    // Only update if new score is higher
                    if (newScore > currentData.score) {
                        await set(playerRef, {
                            name: name,
                            score: newScore,
                            timestamp: Date.now()
                        });
                    }
                } else {
                    // First score for this player
                    await set(playerRef, {
                        name: name,
                        score: newScore,
                        timestamp: Date.now()
                    });
                }
            } catch (error) {
                console.error('Error saving score:', error);
            }
        }

        // Fetch and display scoreboard
        async function fetchAndDisplayScoreboard() {
            const container = document.getElementById('scoreboardContainer');
            const list = document.getElementById('scoreboardList');

            if (!scoreboardEnabled) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            list.innerHTML = '<div class="scoreboard-loading">Loading rankings...</div>';

            try {
                const scoresRef = ref(database, 'scores');
                const snapshot = await get(scoresRef);

                if (snapshot.exists()) {
                    const scores = [];
                    snapshot.forEach((child) => {
                        scores.push(child.val());
                    });

                    // Sort by score descending
                    scores.sort((a, b) => b.score - a.score);

                    // Take top 10
                    const topScores = scores.slice(0, 10);

                    if (topScores.length === 0) {
                        list.innerHTML = '<div class="scoreboard-loading">No scores yet. Be the first!</div>';
                        return;
                    }

                    list.innerHTML = topScores.map((entry, index) => {
                        const isCurrentPlayer = playerName && entry.name.toLowerCase() === playerName.toLowerCase();
                        return `
                            <div class="scoreboard-entry ${isCurrentPlayer ? 'current-player' : ''}">
                                <span class="scoreboard-rank">${index + 1}.</span>
                                <span class="scoreboard-name">${escapeHtml(entry.name)}</span>
                                <span class="scoreboard-score">${entry.score.toLocaleString()}</span>
                            </div>
                        `;
                    }).join('');
                } else {
                    list.innerHTML = '<div class="scoreboard-loading">No scores yet. Be the first!</div>';
                }
            } catch (error) {
                console.error('Error fetching scoreboard:', error);
                list.innerHTML = '<div class="scoreboard-loading">Could not load rankings</div>';
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Set up the game over hook for scoreboard integration
        window.onGameOver = async function(gameData) {
            // Save score and fetch scoreboard
            if (scoreboardEnabled && playerName) {
                await saveHighScore(playerName, gameData.score);
            }
            await fetchAndDisplayScoreboard();
        };
    </script>
</body>
</html>
